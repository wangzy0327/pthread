# pthread 多线程

### 什么是线程

```
线程对应的英文名称为"thread"，它的功能是执行应用程序中的某个具体任务，比如一段程序、一个函数等
每个进程执行前，操作系统都会为其分配所需的资源，包括要执行的程序代码、数据、内存空间、文件资源等。一个进程至少包含 1 个线程，可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源。
进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程

```

### 进程与线程之间的关系如下图

![img](imgs/thread.jpg "进程与线程之间的关系")

### 第一个线程

**[示例代码](00_first_thread/thread.c)**

### 创建线程

**[示例代码](01_create_thread/thread.c)**

### 终止线程

**[示例代码](02_exit_thread/thread.c)**

**[示例代码](03_cancel_thread/thread.c)**

1. 执行完毕，自行终止
2. 执行过程中遇到pthread_exit()或return 终止
3. 执行过程中，接收其他线程"终止执行"信号，终止

### 获取线程函数的返回值

```
对于一个默认属性的线程 A 来说，线程占用的资源并不会因为执行结束而得到释放。
而通过在其它线程中执行pthread_join(A,NULL);语句，可以轻松实现“及时释放线程 A 所占资源”的目的。
一个线程执行结束的返回值只能由一个 pthread_join() 函数获取，当有多个线程调用 pthread_join() 函数获取同一个线程的执行结果时，哪个线程最先执行 pthread_join() 函数，执行结果就由那个线程获得，其它线程的 pthread_join() 函数都将执行失败。
```

**[示例代码]()**

### 终止线程执行的坑

```
对于默认属性的线程，当有线程借助 pthread_cancel() 函数向它发送 Cancel 信号时，它并不会立即结束执行，而是选择在一个适当的时机结束执行。

所谓适当的时机，POSIX 标准中规定，当线程执行一些特殊的函数时，会响应 Cancel 信号并终止执行，比如常见的 pthread_join()、pthread_testcancel()、sleep()、system() 等，POSIX 标准称此类函数为“cancellation points”（中文可译为“取消点”）。
<pthread.h> 头文件还提供有 pthread_setcancelstate() 和 pthread_setcanceltype() 这两个函数，我们可以手动修改目标线程处理 Cancel 信号的方式。
```

**[示例代码](05_trick_cancel_thread/thread.c)**

### 线程同步机制

```
我们通常将“多个线程同时访问某一公共资源”的现象称为“线程间产生了资源竞争”或者“线程间抢夺公共资源”，线程间竞争资源往往会导致程序的运行结果出现异常，感到匪夷所思，严重时还会导致程序运行崩溃。

幸运地是，Linux 提供了很多种解决方案，确定各个线程可以同步访问进程提供的公共资源（简称“线程同步”）。
所谓线程同步，简单地理解就是：当一个线程访问某公共资源时，其它线程不得访问该资源，它们只能等待此线程访问完成后，再逐个访问该资源。

Linux 环境中，实现线程同步的常用方法有 4 种，分别称为互斥锁、信号量、条件变量和读写锁。

```

**[示例代码](06_sync_thread/thread.c)**

### 使用互斥锁实现线程同步

```
互斥锁（Mutex）又称互斥量或者互斥体，是最简单也最有效地一种线程同步机制。互斥锁的用法和实际生活中的锁非常类似，当一个线程访问公共资源时，会及时地“锁上”该资源，阻止其它线程访问；访问结束后再进行“解锁”操作，将该资源让给其它线程访问。
```

**[示例代码]()**

### 使用信号量实现线程同步

```
信号量又称“信号灯”，主要用于控制同时访问公共资源的线程数量，当线程数量控制在 ≤1 时，该信号量又称二元信号量，功能和互斥锁非常类似；当线程数量控制在 N（≥2）个时，该信号量又称多元信号量，指的是同一时刻最多只能有 N 个线程访问该资源。
```

**[示例代码](08_semaphore_thread/thread.c)**

### 使用条件变量实现线程同步

```
条件变量的功能类似于实际生活中的门，门有“打开”和“关闭”两种状态，分别对应条件变量的“成立”状态和“不成立”状态。当条件变量“不成立”时，任何线程都无法访问资源，只能等待条件变量成立；一旦条件变量成立，所有等待的线程都会恢复执行，访问目标资源。为了防止各个线程竞争资源，条件变量总是和互斥锁搭配使用。
条件变量本质也是一个全局变量，它的功能是阻塞线程，直至接收到“条件成立”的信号后，被阻塞的线程才能继续执行
```

**[示例代码](09_condition_thread/thread.c)**

### 使用读写锁实现线程同步

```
多线程程序中，如果大多数线程都是对公共资源执行读取操作，仅有少量的线程对公共资源进行修改，这种情况下可以使用读写锁解决线程同步问题。
本质上，读写锁就是一个全局变量，发出读请求和写请求的线程都可以访问它。为了区别线程发出的请求类别，当读写锁被发出读请求的线程占用时，我们称它为“读锁”；当读写锁被发出写请求的线程占用时，称它为“写锁”。
```

| 当前读写锁的状态 | 线程发出“读”请求 | 线程发出“写”请求 |
| ---------------- | ------------------ | ------------------ |
| 无锁             | 允许占用           | 允许占用           |
| 读锁             | 允许占用           | 阻塞线程执行       |
| 写锁             | 阻塞线程执行       | 阻塞线程执行       |

**[示例代码](10_read_write_lock_thread/thread.c)**

### 避免线程发生死锁

**[示例代码](11_deadlock_thread/thread.c)**

避免死锁的建议：

1）使用互斥锁、信号量、条件变量和读写锁实现线程同步时，需要注意：

占用互斥锁的线程，执行完成前必须及时解锁；

通过sem_wait()函数占用信号量资源的线程，执行完成前必须调用sem_post()函数及时释放；

当线程因pthread_cond_wait()函数被阻塞时，一定要保证有其他线程唤醒此线程；

无论线程占用的是读锁还是写锁，都必须及时解锁

2）POSIX标准中，很多阻塞线程执行的函数都提供有tryxxx()和timexxx()两个版本，例如 pthread_mutex_lock() 和 pthread_mutex_trylock()、sem_wait() 和 sem_trywait()、pthread_cond_wait() 和 pthread_cond_timedwait() 等，它们可以完成同样的功能，但 tryxxx() 版本的函数不会阻塞线程，timexxx() 版本的函数不会一直阻塞线程。

3）多线程程序中，多个线程请求资源的顺序最好保持一致。例如：线程 t1 先请求 mutex 锁然后再请求 mutex2 锁，而 t2 则是先请求 mutex2 锁然后再请求 mutex 锁，这就是典型的因“请求资源顺序不一致”导致发生了线程死锁的情况。

### 线程属性（自定义线程属性）

```cpp
#include <pthread.h>
void * threadFun(void* args){
    //......
}
pthread_t myThread;
pthread_create(&myThread, NULL, ThreadFun, NULL);
//线程属性变量
pthread_attr_t myAttr;
```

程序中，pthread_create()函数需要传递4个参数，其中第二个参数NULL表示以系统默认的属性创建线程

**[示例代码](12_self_property_thread/thread.c)**

### 使用C++11进行多线程编程

```
C++ 11 标准中新引入了与多线程编程相关的多个头文件，包括 <thread>、<mutex>、<future>、<condition_variable> 和 <atomic>

```

* 线程的创建与使用
  [示例1]()
  [示例2]()

thread类常用的成员函数

| 成员函数   | 功能                                                                                   |
| ---------- | -------------------------------------------------------------------------------------- |
| get_id()   | 获取当前thread对象的ID                                                                 |
| joinable() | 判断当前线程是否支持join()成员函数                                                     |
| join()     | 阻塞当前thread对象所在的线程，直至thread对象表示的线程执行完毕后，所在线程才能继续执行 |
| detach()   | 将当前线程从调用该函数的线程中分离出去，它们彼此独立                                   |
| swap()     | 交换两个线程的状态                                                                     |

注意：每个thread 对象在调用析构函数销毁前，要么调用 join() 函数令主线程等待子线程执行完成，要么调用 detach() 函数将子线程和主线程分离，两者比选其一，否则程序可能存在以下两个问题。

1. 线程占用的资源将无法全部释放，造成内存泄漏；
2. 当主线程执行完成而子线程未执行完成时，程序执行将引发异常。

   this_thread命名空间常用函数

   | 函数          | 功能                                  |
   | ------------- | ------------------------------------- |
   | get_id()      | 获得当前线程的ID                      |
   | yield()       | 阻塞当前线程，直至条件成熟            |
   | sleep_until() | 阻塞当前线程，直至某个时间点为止      |
   | sleep_for()   | 阻塞当前线程指定的时间（例如阻塞5秒） |

* 实现线程同步
  [示例]()

  条件变量常用函数

  | 成员函数     | 功能                                                                                                                                                                                                      |
  | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | wait()       | 阻塞当前线程，等待条件成立                                                                                                                                                                                |
  | wait_for()   | 阻塞当前线程的过程中，该函数会自动调用 unlock() 函数解锁互斥锁，从而令其他线程使用公共资源。当条件成立或者超过了指定的等待时间（比如 3 秒），该函数会自动调用 lock() 函数对互斥锁加锁，同时令线程继续执行 |
  | wait_until() | 和 wait_for() 功能类似，不同之处在于，wait_until() 函数可以设定一个具体时间点（例如 2021年4月8日 的某个具体时间），当条件成立或者等待时间超过了指定的时间点，函数会自动对互斥锁加锁，同时线程继续执行     |
  | notify_one() | 向其中一个正在等待的线程发送“条件成立”的信号                                                                                                                                                            |
  | notify_all() | 向所有等待的线程发送“条件成立”的信号                                                                                                                                                                    |

**[示例代码]()**

### 将Linux多线程程序移植到Windows

**[示例代码]()**
